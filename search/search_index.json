{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ryan Morshead Email | GitHub | LinkedIn | Twitter If only there was more time to explain how little time I seem to have... I write music , cook fancy meals, travel, hike, camp, backpack, love (or need?) coffee, swing dance on occasion, and in whatever time is left... develop software for fun and for profit . photo credit","title":"Home"},{"location":"#ryan-morshead","text":"Email | GitHub | LinkedIn | Twitter If only there was more time to explain how little time I seem to have... I write music , cook fancy meals, travel, hike, camp, backpack, love (or need?) coffee, swing dance on occasion, and in whatever time is left... develop software for fun and for profit . photo credit","title":"Ryan Morshead"},{"location":"projects/","text":"Projects Music Software iDOM - Python for the Web Gives Python developers the power to create interactive web applications without writing a single line of Javascript. iDOM was originally inspired by Jupyter Widgets and Nteract's VDOM , however it breaks from both by allowing live updates to substantially sized frontend views. Spectate - MVC for Python A library for Python 2 and 3 that can track changes to mutable data types. With spectate complicated protocols for managing updates don't need to be the outward responsibility of a user and can instead be done \"automagically\" in the background. For instance, syncing the state between a server and client can controlled by spectate so user's don't have to.","title":"Projects"},{"location":"projects/#projects","text":"","title":"Projects"},{"location":"projects/#music","text":"","title":"Music"},{"location":"projects/#software","text":"","title":"Software"},{"location":"projects/#idom-python-for-the-web","text":"Gives Python developers the power to create interactive web applications without writing a single line of Javascript. iDOM was originally inspired by Jupyter Widgets and Nteract's VDOM , however it breaks from both by allowing live updates to substantially sized frontend views.","title":" iDOM - Python for the Web"},{"location":"projects/#spectate-mvc-for-python","text":"A library for Python 2 and 3 that can track changes to mutable data types. With spectate complicated protocols for managing updates don't need to be the outward responsibility of a user and can instead be done \"automagically\" in the background. For instance, syncing the state between a server and client can controlled by spectate so user's don't have to.","title":" Spectate - MVC for Python"},{"location":"resume/","text":"Ryan Morshead Email | GitHub | LinkedIn | Twitter A software engineer with experience across the stack as a learner and a leader in open source and enterprise. Having worked on projects from their inception to their long decline he believes the written and verbal communication of one's work forms the foundation of its sustainability. Work Experience Software Engineer II | 23andMe | May 2020 - Present A seasoned member of a now growing Feature Engineering team tasked with developing a broader system and set of services that reduce the time it takes for scientists to turn their experiments into verified, trustworthy, and valuable user-facing model features. Software Engineer I | 23andMe | Jul 2019 - May 2020 One of the first hires for a new Feature Engineering team working to develop in house tooling to improve workflows and pipelines for researchers and data scientists across the company. Principle team member developing a library for defining features at 23andMe Delivered the library and several core model features ahead of schedule Made comprehensize docs and tests that are loved by users, and devs alike Software Engineer | Cisco | Jul 2018 - Jul 2019 Brought onto Cisco's Engineering Licensing team as the first hire on a new project intended to serve Cisco's licensing needs for its present and future cloud products. Delivered to 3 product teams including Cisco's new DNA Center . Re-engineered Cisco's Smart Licensing for Python and the cloud. Designed goals and deadlines for long term projects. Screened, interviewed, recommended, and trained new hires. Platforms Engineer | Primer AI | Nov 2017 - Apr 2018 Part of a growing team of engineers tasked with supporting data scientists developing machine learning solutions to text based problems. Added backend REST API features and expanded test coverage. Built and deployed simple micro service using Python and Flask. Learned React on the job to aide in developing frontend components. Introduced teams to Jupyter as a tool for reproducible and shareable science. Engineer in Test | Apple Maps | Jul 2017 - Nov 2017 One of two engineers brought on to develop a UI test automation framework for a map editor used in the production pipeline for Apple Maps. Developed a framework around Selenium for easily testing UI applications. Expanded test coverage to relieve manual testers. Communicated with core devs to ensure products meet expectations. Testimonials His knowledge of the inner workings of Python are easily some of the best I\u2019ve seen... he is also one of the most genuine and cooperative people I have had the pleasure of working with. Alvin Yates - Former Manager Supplemental Work 23andMentor | 23andMe | Jul 2020 - Sep 2020 Participated in 23andMe's mentoship pilot program. Taught a collegue with minimal coding experience to code in Python through 1-2 hour weekly sessions. The curiculum was relatively unstructured and primarilly guided by the mentee's curiosities and interests. By the end of the program the mentee was able to: Write Python scripts to solve basic algorithms questions Reach out to other colleagues to find ways to apply her newfound skills GSOC Mentor | Matplotlib | Jun 2017 - Sep 2017 Guided a student through Google's Summer of Code as their sole mentor in order to continue the work of integrating Traitlets into Matplotlib. Reviewed the student's code Introduced them to Git and GitHub as tools for collaboration Organized and enforced regular meetings to display daily progress. Owned Projects IDOM - React, but in Python Gives Python developers the power to create interactive web applications without writing a single line of Javascript. IDOM takes large inspiration from React Hooks and effectively replicates their behavior enabling users to define declarative and composable UI components. Spectate - MVC for Python A library for Python 2 and 3 that can track changes to mutable data types. With spectate complicated protocols for managing updates don't need to be the outward responsibility of a user and can instead be done \"automagically\" in the background. For instance, syncing the state between a server and client can controlled by spectate so user's don't have to. Maintained Projects Traitlets - IPython and Jupyter Traitlets is a pure Python library for enforcing strong typing, observing changes to tracked data, and reading configuring values from files or from command line arguments. Traitlets powers the configuration system of IPython and Jupyter and the declarative API of IPython's interactive widgets . Technical Skills Expert Advanced Competent Languages Python Javascript SQL, HTML, CSS Frameworks Flask , Asyncio React Tools Git, PyTest, Sphinx, Tox Docker, Jenkins, Travis CI GitHub Actions Databases Redshift, PostgreSQL, Redis Clouds AWS Education B.A. Physics","title":"Resume"},{"location":"resume/#ryan-morshead","text":"Email | GitHub | LinkedIn | Twitter A software engineer with experience across the stack as a learner and a leader in open source and enterprise. Having worked on projects from their inception to their long decline he believes the written and verbal communication of one's work forms the foundation of its sustainability.","title":"Ryan Morshead"},{"location":"resume/#work-experience","text":"","title":"Work Experience"},{"location":"resume/#software-engineer-ii-23andme-may-2020-present","text":"A seasoned member of a now growing Feature Engineering team tasked with developing a broader system and set of services that reduce the time it takes for scientists to turn their experiments into verified, trustworthy, and valuable user-facing model features.","title":"Software Engineer II | 23andMe | May 2020 - Present"},{"location":"resume/#software-engineer-i-23andme-jul-2019-may-2020","text":"One of the first hires for a new Feature Engineering team working to develop in house tooling to improve workflows and pipelines for researchers and data scientists across the company. Principle team member developing a library for defining features at 23andMe Delivered the library and several core model features ahead of schedule Made comprehensize docs and tests that are loved by users, and devs alike","title":"Software Engineer I | 23andMe | Jul 2019 - May 2020"},{"location":"resume/#software-engineer-cisco-jul-2018-jul-2019","text":"Brought onto Cisco's Engineering Licensing team as the first hire on a new project intended to serve Cisco's licensing needs for its present and future cloud products. Delivered to 3 product teams including Cisco's new DNA Center . Re-engineered Cisco's Smart Licensing for Python and the cloud. Designed goals and deadlines for long term projects. Screened, interviewed, recommended, and trained new hires.","title":"Software Engineer | Cisco | Jul 2018 - Jul 2019"},{"location":"resume/#platforms-engineer-primer-ai-nov-2017-apr-2018","text":"Part of a growing team of engineers tasked with supporting data scientists developing machine learning solutions to text based problems. Added backend REST API features and expanded test coverage. Built and deployed simple micro service using Python and Flask. Learned React on the job to aide in developing frontend components. Introduced teams to Jupyter as a tool for reproducible and shareable science.","title":"Platforms Engineer | Primer AI | Nov 2017 - Apr 2018"},{"location":"resume/#engineer-in-test-apple-maps-jul-2017-nov-2017","text":"One of two engineers brought on to develop a UI test automation framework for a map editor used in the production pipeline for Apple Maps. Developed a framework around Selenium for easily testing UI applications. Expanded test coverage to relieve manual testers. Communicated with core devs to ensure products meet expectations.","title":"Engineer in Test | Apple Maps | Jul 2017 - Nov 2017"},{"location":"resume/#testimonials","text":"His knowledge of the inner workings of Python are easily some of the best I\u2019ve seen... he is also one of the most genuine and cooperative people I have had the pleasure of working with. Alvin Yates - Former Manager","title":"Testimonials"},{"location":"resume/#supplemental-work","text":"","title":"Supplemental Work"},{"location":"resume/#23andmentor-23andme-jul-2020-sep-2020","text":"Participated in 23andMe's mentoship pilot program. Taught a collegue with minimal coding experience to code in Python through 1-2 hour weekly sessions. The curiculum was relatively unstructured and primarilly guided by the mentee's curiosities and interests. By the end of the program the mentee was able to: Write Python scripts to solve basic algorithms questions Reach out to other colleagues to find ways to apply her newfound skills","title":"23andMentor | 23andMe | Jul 2020 - Sep 2020"},{"location":"resume/#gsoc-mentor-matplotlib-jun-2017-sep-2017","text":"Guided a student through Google's Summer of Code as their sole mentor in order to continue the work of integrating Traitlets into Matplotlib. Reviewed the student's code Introduced them to Git and GitHub as tools for collaboration Organized and enforced regular meetings to display daily progress.","title":"GSOC Mentor | Matplotlib | Jun 2017 - Sep 2017"},{"location":"resume/#owned-projects","text":"","title":"Owned Projects"},{"location":"resume/#idom-react-but-in-python","text":"Gives Python developers the power to create interactive web applications without writing a single line of Javascript. IDOM takes large inspiration from React Hooks and effectively replicates their behavior enabling users to define declarative and composable UI components.","title":" IDOM - React, but in Python"},{"location":"resume/#spectate-mvc-for-python","text":"A library for Python 2 and 3 that can track changes to mutable data types. With spectate complicated protocols for managing updates don't need to be the outward responsibility of a user and can instead be done \"automagically\" in the background. For instance, syncing the state between a server and client can controlled by spectate so user's don't have to.","title":" Spectate - MVC for Python"},{"location":"resume/#maintained-projects","text":"","title":"Maintained Projects"},{"location":"resume/#traitlets-ipython-and-jupyter","text":"Traitlets is a pure Python library for enforcing strong typing, observing changes to tracked data, and reading configuring values from files or from command line arguments. Traitlets powers the configuration system of IPython and Jupyter and the declarative API of IPython's interactive widgets .","title":" Traitlets - IPython and Jupyter"},{"location":"resume/#technical-skills","text":"Expert Advanced Competent Languages Python Javascript SQL, HTML, CSS Frameworks Flask , Asyncio React Tools Git, PyTest, Sphinx, Tox Docker, Jenkins, Travis CI GitHub Actions Databases Redshift, PostgreSQL, Redis Clouds AWS","title":"Technical Skills"},{"location":"resume/#education","text":"B.A. Physics","title":"Education"},{"location":"articles/2021/idom-react-but-its-python/article/","text":"IDOM - It's React, but in Python IDOM is a new declarative Python package for building highly interactive user interfaces. IDOM takes inspiration from React , and wherever possible, attempts to achieve parity with the features it copies more directly. Nowhere is this more evident than the version of React's often lauded \"Hooks\" that IDOM implements in Python. At a glance, the similarities between IDOM and React are rather striking. Below is a React component which defines a simple Counter displaying the number of times a button has been clicked: import React , { useState } from \"react\" ; import ReactDOM from \"react-dom\" ; function Counter () { const [ count , setCount ] = useState ( 0 ); return ( < div > < button onClick = {() => setCount ( count + 1 )}> Click me ! </ button > < p >{ `Click count: ${ count } ` }</ p > </ div > ); } ReactDOM . render (< Counter />, document . getElementById ( \"root\" )); And this is the same component implemented in Python using IDOM: import idom @idom . component def Counter (): count , set_count = idom . hooks . use_state ( 0 ) return idom . html . div ( idom . html . button ( { \"onClick\" : lambda event : set_count ( count + 1 )}, \"Click me!\" ), idom . html . p ( f \"Click count: { count } \" ) ) idom . run ( Counter ) Which, when displayed in your browser, should look something like this: Why Do We Need IDOM? Over the past 5 years front-end developers seem to have arrived at the conclusion that declarative programming is usually better than imperative. Put more simply, mutable state in programs can quickly lead to unsustainable complexity. This trend is largely evidenced by the rise of Javascript frameworks like Vue and React which describe the logic of computations without explicitly stating their control flow. So what does this have to do with Python and IDOM? Well, because browsers are the de facto \"operating system of the internet\", even back-end languages like Python have had to figure out clever ways to integrate with them. While standard REST APIs are well suited to applications built using HTML templates, modern browser users expect a higher degree of interactivity than this alone can achieve. A variety of Python packages have since been created to help solve this problem: IPyWidgets - Adds interactive widgets to Jupyter Notebooks Dash - Allows data scientists to produces enterprise-ready analytic apps Streamlit - Turns simple Python scripts into interactive dashboards Bokeh - An interactive visualization library for modern web browsers However they each have drawbacks that can make them difficult to use. Restrictive ecosystems - UI components developed for one framework cannot be easily ported to any of the others because their APIs are either too complex, undocumented, or are structurally inaccesible. Imperative paradigm - IPyWidgets and Bokeh have not embraced the same declarative design principles pioneered by front-end developers. Streamlit and Dash on the otherhand, are decarative, but fall short of the features provided by React or Vue. Limited layouts - At their initial inception, the developers of these libraries were driven by the visualization needs of data scientists so the ability to create complex UI layouts may not have been a primary engineering goal. A future article will address specific comparisons to each of the projects mentioned above, but for now, we'll just focus on IDOM and its solutions to the problems above. Ecosystem Independence IDOM has a flexible set of core abstractions that allow it to interface with its peers. At the time of writing, both Jupyter and Dash are supported, while Streamlit and Bokeh are in the works: idom-jupyter (try it now with Binder ) idom-dash By providing well defined interfaces and straighforward protocols, IDOM makes it easy to swap out any part of the stack with an alternate implementation if you want to. For example, if you need a different web server for your application, IDOM already has 3 options to choose from or, use as blueprints to create your own: Sanic Flask Tornado You can even target your usage of IDOM in your production-grade applications with IDOM's Javascript React client library . Just install it in your front-end app and connect a back-end websocket that's serving up IDOM models. IDOM's own documentation acts as a prime example for this targeted usage - most of the page is static HTML, but embedded in it are interactive examples that feature live views being served from a web socket: Declarative Components IDOM, by adopting the hook design pattern from React, inherits many of its aesthetic and functional characteristics. For those unfamiliar with hooks, user interfaces are composed of basic HTML elements that are constructed and returned by special functions called \"components\". Then, through the magic of hooks, those components can be made to have state. Consider the component below which displays a basic representation of an AND-gate : import idom @idom . component def AndGate (): input_1 , toggle_1 = use_toggle () input_2 , toggle_2 = use_toggle () return idom . html . div ( idom . html . input ( { \"type\" : \"checkbox\" , \"onClick\" : lambda event : toggle_1 ()} ), idom . html . input ( { \"type\" : \"checkbox\" , \"onClick\" : lambda event : toggle_2 ()} ), idom . html . pre ( f \" { input_1 } AND { input_2 } = { input_1 and input_2 } \" ), ) def use_toggle (): state , set_state = idom . hooks . use_state ( False ) def toggle_state (): set_state ( lambda old_state : not old_state ) return state , toggle_state idom . run ( AndGate ) Here's a very high level summary of how it works... the first time a view of the component above is rendered, the AndGate function is called where its initial state for input_1 and input_2 is False . The function then returns a series of HTML elements with callbacks that respond to client-side events. Machinery behind the scenes subsequently realizes that declaration and displays two checkbox buttons with the text False AND False = False . Later, when a user clicks the now visible checkbox buttons, client-side events are triggered, the associated callbacks respond by inverting the old state from False to True , and a re-render of the component is scheduled. When re-rendering, the function is again called, this time though, where input_1 and input_2 have been updated to reflect the new state , thus causing the displayed text to change. Consider the fact that nowhere in the example above does the code describe how to evolve the frontend view when events occur. Instead, it declares that, given a particular state, this is how the view should look. It's then IDOM's responsibility to figure out how to bring that declaration into being. This behavior of defining outcomes without stating the means by which to achieve them is what makes components in IDOM and React \"declarative\". For comparison, a hypothetical, and a more imperative approach to defining the same interface might look similar to the following: layout = Layout () def and_gate (): state = { \"input_1\" : False , \"input_2\" : False } output_text = html . pre () update_and_gate_output_text ( output_text , state ) def toggle_input ( index ): state [ f \"input_ { index } \" ] = not state [ f \"input_ { index } \" ] update_and_gate_output_text ( output_text , state ) return html . div ( html . input ( { \"type\" : \"checkbox\" , \"onClick\" : lambda event : toggle_input ( 1 )} ), html . input ( { \"type\" : \"checkbox\" , \"onClick\" : lambda event : toggle_input ( 2 )} ), output_text ) def update_and_gate_output_text ( text , state ): text . update ( children = \" {input_1} AND {input_2} = {output} \" . format ( input_1 = state [ \"input_1\" ], input_2 = state [ \"input_2\" ], output = state [ \"input_1\" ] and state [ \"input_2\" ], ) ) layout . add_element ( and_gate ()) layout . run () In this imperative incarnation there are several disadvantages: Refactoring is difficult - Functions are much more specialized to their particular usages in and_gate . By comparison, use_toggle from the declarative implementation could be applicable to any scenario where boolean indicators should be toggled on and off. No clear static relations - There is no one section of code in which one can discern the basic structure and behaviors of the view. This issue is exemplified by the fact that we must call update_and_gate_output_text from two different locations. Once in the body of and_gate and again in the body of the callback toggle_input . This means that, to understand what the output_text might contain, we must also understand all the business logic that surrounds it. Referential links cause complexity - To evolve the view, various callbacks must hold references to all the elements that they will update. At the outset this makes writing programs difficult since elements must be passed up and down the call stack wherever they are needed. Considered further though, it also means that a function layers down in the call stack can accidentally or intentionally impact the behavior of ostensibly unrelated parts of the program. Virtual Document Object Model To communicate between their back-end Python servers and Javascript clients, IDOM's peers take an approach that aligns fairly closely with the Model-View-Controller design pattern - the controller lives server-side (though not always), the model is what's synchronized between the server and client, and the view is run client-side in Javascript. To draw it out might look something like this: By contrast, IDOM uses something called a Virtual Document Object Model ( VDOM ) to construct a representation of the view. The VDOM is constructed on the Python side by components then, as it evolves, IDOM's layout computes VDOM-diffs and wires them to its Javascript client: This process, in addition to drastically reducing complexity, means that Python developers with just a little bit of HTML and CSS knowledge can easily create elabortate interfaces because they have complete control over the view. Of course many users probably don't care about the details and just want high level components, but for those who do it's easy to distribute their creations for others to use. Custom Javascript Components Now, if you're thinking about how VDOM is being used critically, you may have thought... Isn't wiring a virtual representation of the view to the client, even if its diffed, expensive? And yes, while the performance of IDOM is sufficient for most use cases, there are inevitably scenarios where this could be an issue. Thankfully though, just like it's peers, IDOM makes it possible to seemlesly integrate Javascript components . They can be custom built for your use case, or you can just leverage the existing Javascript ecosystem without any extra work: import json import idom material_ui = idom . install ( \"@material-ui/core\" , fallback = \"loading...\" ) @idom . component def DisplaySliderEvents (): event , set_event = idom . hooks . use_state ( None ) return idom . html . div ( material_ui . Slider ( { \"color\" : \"primary\" , \"step\" : 10 , \"min\" : 0 , \"max\" : 100 , \"defaultValue\" : 50 , \"valueLabelDisplay\" : \"auto\" , \"onChange\" : lambda * event : set_event ( event ), } ), idom . html . pre ( json . dumps ( event , indent = 2 )), ) idom . run ( DisplaySliderEvents ) Conclusion Building highly interactive web applications as a Python developer has historically been a great challenge. However IDOM changes that. Knowing just basic HTML, CSS, and Python, you can make everything from slideshows to dashboards and use it wherever you need it, whether that's in a Jupyter Notebook or an existing web application. To learn more check out: installation instructions where to get started interactive examples and much more !","title":"IDOM - It's React, but in Python"},{"location":"articles/2021/idom-react-but-its-python/article/#idom-its-react-but-in-python","text":"IDOM is a new declarative Python package for building highly interactive user interfaces. IDOM takes inspiration from React , and wherever possible, attempts to achieve parity with the features it copies more directly. Nowhere is this more evident than the version of React's often lauded \"Hooks\" that IDOM implements in Python. At a glance, the similarities between IDOM and React are rather striking. Below is a React component which defines a simple Counter displaying the number of times a button has been clicked: import React , { useState } from \"react\" ; import ReactDOM from \"react-dom\" ; function Counter () { const [ count , setCount ] = useState ( 0 ); return ( < div > < button onClick = {() => setCount ( count + 1 )}> Click me ! </ button > < p >{ `Click count: ${ count } ` }</ p > </ div > ); } ReactDOM . render (< Counter />, document . getElementById ( \"root\" )); And this is the same component implemented in Python using IDOM: import idom @idom . component def Counter (): count , set_count = idom . hooks . use_state ( 0 ) return idom . html . div ( idom . html . button ( { \"onClick\" : lambda event : set_count ( count + 1 )}, \"Click me!\" ), idom . html . p ( f \"Click count: { count } \" ) ) idom . run ( Counter ) Which, when displayed in your browser, should look something like this:","title":"IDOM - It's React, but in Python"},{"location":"articles/2021/idom-react-but-its-python/article/#why-do-we-need-idom","text":"Over the past 5 years front-end developers seem to have arrived at the conclusion that declarative programming is usually better than imperative. Put more simply, mutable state in programs can quickly lead to unsustainable complexity. This trend is largely evidenced by the rise of Javascript frameworks like Vue and React which describe the logic of computations without explicitly stating their control flow. So what does this have to do with Python and IDOM? Well, because browsers are the de facto \"operating system of the internet\", even back-end languages like Python have had to figure out clever ways to integrate with them. While standard REST APIs are well suited to applications built using HTML templates, modern browser users expect a higher degree of interactivity than this alone can achieve. A variety of Python packages have since been created to help solve this problem: IPyWidgets - Adds interactive widgets to Jupyter Notebooks Dash - Allows data scientists to produces enterprise-ready analytic apps Streamlit - Turns simple Python scripts into interactive dashboards Bokeh - An interactive visualization library for modern web browsers However they each have drawbacks that can make them difficult to use. Restrictive ecosystems - UI components developed for one framework cannot be easily ported to any of the others because their APIs are either too complex, undocumented, or are structurally inaccesible. Imperative paradigm - IPyWidgets and Bokeh have not embraced the same declarative design principles pioneered by front-end developers. Streamlit and Dash on the otherhand, are decarative, but fall short of the features provided by React or Vue. Limited layouts - At their initial inception, the developers of these libraries were driven by the visualization needs of data scientists so the ability to create complex UI layouts may not have been a primary engineering goal. A future article will address specific comparisons to each of the projects mentioned above, but for now, we'll just focus on IDOM and its solutions to the problems above.","title":"Why Do We Need IDOM?"},{"location":"articles/2021/idom-react-but-its-python/article/#ecosystem-independence","text":"IDOM has a flexible set of core abstractions that allow it to interface with its peers. At the time of writing, both Jupyter and Dash are supported, while Streamlit and Bokeh are in the works: idom-jupyter (try it now with Binder ) idom-dash By providing well defined interfaces and straighforward protocols, IDOM makes it easy to swap out any part of the stack with an alternate implementation if you want to. For example, if you need a different web server for your application, IDOM already has 3 options to choose from or, use as blueprints to create your own: Sanic Flask Tornado You can even target your usage of IDOM in your production-grade applications with IDOM's Javascript React client library . Just install it in your front-end app and connect a back-end websocket that's serving up IDOM models. IDOM's own documentation acts as a prime example for this targeted usage - most of the page is static HTML, but embedded in it are interactive examples that feature live views being served from a web socket:","title":"Ecosystem Independence"},{"location":"articles/2021/idom-react-but-its-python/article/#declarative-components","text":"IDOM, by adopting the hook design pattern from React, inherits many of its aesthetic and functional characteristics. For those unfamiliar with hooks, user interfaces are composed of basic HTML elements that are constructed and returned by special functions called \"components\". Then, through the magic of hooks, those components can be made to have state. Consider the component below which displays a basic representation of an AND-gate : import idom @idom . component def AndGate (): input_1 , toggle_1 = use_toggle () input_2 , toggle_2 = use_toggle () return idom . html . div ( idom . html . input ( { \"type\" : \"checkbox\" , \"onClick\" : lambda event : toggle_1 ()} ), idom . html . input ( { \"type\" : \"checkbox\" , \"onClick\" : lambda event : toggle_2 ()} ), idom . html . pre ( f \" { input_1 } AND { input_2 } = { input_1 and input_2 } \" ), ) def use_toggle (): state , set_state = idom . hooks . use_state ( False ) def toggle_state (): set_state ( lambda old_state : not old_state ) return state , toggle_state idom . run ( AndGate ) Here's a very high level summary of how it works... the first time a view of the component above is rendered, the AndGate function is called where its initial state for input_1 and input_2 is False . The function then returns a series of HTML elements with callbacks that respond to client-side events. Machinery behind the scenes subsequently realizes that declaration and displays two checkbox buttons with the text False AND False = False . Later, when a user clicks the now visible checkbox buttons, client-side events are triggered, the associated callbacks respond by inverting the old state from False to True , and a re-render of the component is scheduled. When re-rendering, the function is again called, this time though, where input_1 and input_2 have been updated to reflect the new state , thus causing the displayed text to change. Consider the fact that nowhere in the example above does the code describe how to evolve the frontend view when events occur. Instead, it declares that, given a particular state, this is how the view should look. It's then IDOM's responsibility to figure out how to bring that declaration into being. This behavior of defining outcomes without stating the means by which to achieve them is what makes components in IDOM and React \"declarative\". For comparison, a hypothetical, and a more imperative approach to defining the same interface might look similar to the following: layout = Layout () def and_gate (): state = { \"input_1\" : False , \"input_2\" : False } output_text = html . pre () update_and_gate_output_text ( output_text , state ) def toggle_input ( index ): state [ f \"input_ { index } \" ] = not state [ f \"input_ { index } \" ] update_and_gate_output_text ( output_text , state ) return html . div ( html . input ( { \"type\" : \"checkbox\" , \"onClick\" : lambda event : toggle_input ( 1 )} ), html . input ( { \"type\" : \"checkbox\" , \"onClick\" : lambda event : toggle_input ( 2 )} ), output_text ) def update_and_gate_output_text ( text , state ): text . update ( children = \" {input_1} AND {input_2} = {output} \" . format ( input_1 = state [ \"input_1\" ], input_2 = state [ \"input_2\" ], output = state [ \"input_1\" ] and state [ \"input_2\" ], ) ) layout . add_element ( and_gate ()) layout . run () In this imperative incarnation there are several disadvantages: Refactoring is difficult - Functions are much more specialized to their particular usages in and_gate . By comparison, use_toggle from the declarative implementation could be applicable to any scenario where boolean indicators should be toggled on and off. No clear static relations - There is no one section of code in which one can discern the basic structure and behaviors of the view. This issue is exemplified by the fact that we must call update_and_gate_output_text from two different locations. Once in the body of and_gate and again in the body of the callback toggle_input . This means that, to understand what the output_text might contain, we must also understand all the business logic that surrounds it. Referential links cause complexity - To evolve the view, various callbacks must hold references to all the elements that they will update. At the outset this makes writing programs difficult since elements must be passed up and down the call stack wherever they are needed. Considered further though, it also means that a function layers down in the call stack can accidentally or intentionally impact the behavior of ostensibly unrelated parts of the program.","title":"Declarative Components"},{"location":"articles/2021/idom-react-but-its-python/article/#virtual-document-object-model","text":"To communicate between their back-end Python servers and Javascript clients, IDOM's peers take an approach that aligns fairly closely with the Model-View-Controller design pattern - the controller lives server-side (though not always), the model is what's synchronized between the server and client, and the view is run client-side in Javascript. To draw it out might look something like this: By contrast, IDOM uses something called a Virtual Document Object Model ( VDOM ) to construct a representation of the view. The VDOM is constructed on the Python side by components then, as it evolves, IDOM's layout computes VDOM-diffs and wires them to its Javascript client: This process, in addition to drastically reducing complexity, means that Python developers with just a little bit of HTML and CSS knowledge can easily create elabortate interfaces because they have complete control over the view. Of course many users probably don't care about the details and just want high level components, but for those who do it's easy to distribute their creations for others to use.","title":"Virtual Document Object Model"},{"location":"articles/2021/idom-react-but-its-python/article/#custom-javascript-components","text":"Now, if you're thinking about how VDOM is being used critically, you may have thought... Isn't wiring a virtual representation of the view to the client, even if its diffed, expensive? And yes, while the performance of IDOM is sufficient for most use cases, there are inevitably scenarios where this could be an issue. Thankfully though, just like it's peers, IDOM makes it possible to seemlesly integrate Javascript components . They can be custom built for your use case, or you can just leverage the existing Javascript ecosystem without any extra work: import json import idom material_ui = idom . install ( \"@material-ui/core\" , fallback = \"loading...\" ) @idom . component def DisplaySliderEvents (): event , set_event = idom . hooks . use_state ( None ) return idom . html . div ( material_ui . Slider ( { \"color\" : \"primary\" , \"step\" : 10 , \"min\" : 0 , \"max\" : 100 , \"defaultValue\" : 50 , \"valueLabelDisplay\" : \"auto\" , \"onChange\" : lambda * event : set_event ( event ), } ), idom . html . pre ( json . dumps ( event , indent = 2 )), ) idom . run ( DisplaySliderEvents )","title":"Custom Javascript Components"},{"location":"articles/2021/idom-react-but-its-python/article/#conclusion","text":"Building highly interactive web applications as a Python developer has historically been a great challenge. However IDOM changes that. Knowing just basic HTML, CSS, and Python, you can make everything from slideshows to dashboards and use it wherever you need it, whether that's in a Jupyter Notebook or an existing web application. To learn more check out: installation instructions where to get started interactive examples and much more !","title":"Conclusion"}]}