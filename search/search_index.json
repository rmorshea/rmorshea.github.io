{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ryan Morshead Email | GitHub | LinkedIn | Twitter If only there was more time to explain how little time I seem to have... I write music , cook fancy meals, travel, hike, camp, backpack, love (or need?) coffee, swing dance on occasion, and in whatever time is left... develop software for fun and for profit . photo credit","title":"Home"},{"location":"#ryan-morshead","text":"Email | GitHub | LinkedIn | Twitter If only there was more time to explain how little time I seem to have... I write music , cook fancy meals, travel, hike, camp, backpack, love (or need?) coffee, swing dance on occasion, and in whatever time is left... develop software for fun and for profit . photo credit","title":"Ryan Morshead"},{"location":"projects/","text":"Projects Music Software iDOM - Python for the Web Gives Python developers the power to create interactive web applications without writing a single line of Javascript. iDOM was originally inspired by Jupyter Widgets and Nteract's VDOM , however it breaks from both by allowing live updates to substantially sized frontend views. Spectate - MVC for Python A library for Python 2 and 3 that can track changes to mutable data types. With spectate complicated protocols for managing updates don't need to be the outward responsibility of a user and can instead be done \"automagically\" in the background. For instance, syncing the state between a server and client can controlled by spectate so user's don't have to.","title":"Projects"},{"location":"projects/#projects","text":"","title":"Projects"},{"location":"projects/#music","text":"","title":"Music"},{"location":"projects/#software","text":"","title":"Software"},{"location":"projects/#idom-python-for-the-web","text":"Gives Python developers the power to create interactive web applications without writing a single line of Javascript. iDOM was originally inspired by Jupyter Widgets and Nteract's VDOM , however it breaks from both by allowing live updates to substantially sized frontend views.","title":" iDOM - Python for the Web"},{"location":"projects/#spectate-mvc-for-python","text":"A library for Python 2 and 3 that can track changes to mutable data types. With spectate complicated protocols for managing updates don't need to be the outward responsibility of a user and can instead be done \"automagically\" in the background. For instance, syncing the state between a server and client can controlled by spectate so user's don't have to.","title":" Spectate - MVC for Python"},{"location":"resume/","text":"Ryan Morshead Email | GitHub | LinkedIn | Twitter A software engineer with experience across the stack as a learner and a leader in open source and enterprise. Having worked on projects from their inception to their long decline he believes the written and verbal communication of one's work forms the foundation of its sustainability. Technical Skills Expert Advanced Competent Languages Python Javascript SQL, HTML, CSS Frameworks Flask , Asyncio React Tools Git, PyTest, Sphinx, Tox Docker, Jenkins, Travis CI GitHub Actions Databases Redshift, PostgreSQL, Redis Clouds AWS Work Experience Software Engineer II | 23andMe | May 2020 - Present A seasoned member of a now growing Feature Engineering team tasked with developing a broader system and set of services that reduce the time it takes for scientists to turn their experiments into verified, trustworthy, and valuable user-facing model features. Software Engineer I | 23andMe | Jul 2019 - May 2020 One of the first hires for a new Feature Engineering team working to develop in house tooling to improve workflows and pipelines for researchers and data scientists across the company. Principle team member developing a library for defining features at 23andMe Delivered the library and several core model features ahead of schedule Made comprehensize docs and tests that are loved by users, and devs alike Software Engineer | Cisco | Jul 2018 - Jul 2019 Brought onto Cisco's Engineering Licensing team as the first hire on a new project intended to serve Cisco's licensing needs for its present and future cloud products. Delivered to 3 product teams including Cisco's new DNA Center . Re-engineered Cisco's Smart Licensing for Python and the cloud. Designed goals and deadlines for long term projects. Screened, interviewed, recommended, and trained new hires. Platforms Engineer | Primer AI | Nov 2017 - Apr 2018 Part of a growing team of engineers tasked with supporting data scientists developing machine learning solutions to text based problems. Added backend REST API features and expanded test coverage. Built and deployed simple micro service using Python and Flask. Learned React on the job to aide in developing frontend components. Introduced teams to Jupyter as a tool for reproducible and shareable science. Engineer in Test | Apple Maps | Jul 2017 - Nov 2017 One of two engineers brought on to develop a UI test automation framework for a map editor used in the production pipeline for Apple Maps. Developed a framework around Selenium for easily testing UI applications. Expanded test coverage to relieve manual testers. Communicated with core devs to ensure products meet expectations. Supplemental Work 23andMentor | 23andMe | Jul 2020 - Sep 2020 Participated in 23andMe's mentoship pilot program. Taught a collegue with minimal coding experience to code in Python through 1-2 hour weekly sessions. The curiculum was relatively unstructured and primarilly guided by the mentee's curiosities and interests. By the end of the program the mentee was able to: Write Python scripts to solve basic algorithms questions Reach out to other colleagues to find ways to apply her newfound skills GSOC Mentor | Matplotlib | Jun 2017 - Sep 2017 Guided a student through Google's Summer of Code as their sole mentor in order to continue the work of integrating Traitlets into Matplotlib. Reviewed the student's code Introduced them to Git and GitHub as tools for collaboration Organized and enforced regular meetings to display daily progress. Owned Projects IDOM - React, but in Python Gives Python developers the power to create interactive web applications without writing a single line of Javascript. IDOM takes large inspiration from React Hooks and effectively replicates their behavior enabling users to define declarative and composable UI components. Spectate - MVC for Python A library for Python 2 and 3 that can track changes to mutable data types. With spectate complicated protocols for managing updates don't need to be the outward responsibility of a user and can instead be done \"automagically\" in the background. For instance, syncing the state between a server and client can controlled by spectate so user's don't have to. Maintained Projects Traitlets - IPython and Jupyter Traitlets is a pure Python library for enforcing strong typing, observing changes to tracked data, and reading configuring values from files or from command line arguments. Traitlets powers the configuration system of IPython and Jupyter and the declarative API of IPython's interactive widgets . Recommendations His knowledge of the inner workings of Python are easily some of the best I\u2019ve seen... he is also one of the most genuine and cooperative people I have had the pleasure of working with. Alvin Yates - Former Manager Education B.A. Physics","title":"Resume"},{"location":"resume/#ryan-morshead","text":"Email | GitHub | LinkedIn | Twitter A software engineer with experience across the stack as a learner and a leader in open source and enterprise. Having worked on projects from their inception to their long decline he believes the written and verbal communication of one's work forms the foundation of its sustainability.","title":"Ryan Morshead"},{"location":"resume/#technical-skills","text":"Expert Advanced Competent Languages Python Javascript SQL, HTML, CSS Frameworks Flask , Asyncio React Tools Git, PyTest, Sphinx, Tox Docker, Jenkins, Travis CI GitHub Actions Databases Redshift, PostgreSQL, Redis Clouds AWS","title":"Technical Skills"},{"location":"resume/#work-experience","text":"","title":"Work Experience"},{"location":"resume/#software-engineer-ii-23andme-may-2020-present","text":"A seasoned member of a now growing Feature Engineering team tasked with developing a broader system and set of services that reduce the time it takes for scientists to turn their experiments into verified, trustworthy, and valuable user-facing model features.","title":"Software Engineer II | 23andMe | May 2020 - Present"},{"location":"resume/#software-engineer-i-23andme-jul-2019-may-2020","text":"One of the first hires for a new Feature Engineering team working to develop in house tooling to improve workflows and pipelines for researchers and data scientists across the company. Principle team member developing a library for defining features at 23andMe Delivered the library and several core model features ahead of schedule Made comprehensize docs and tests that are loved by users, and devs alike","title":"Software Engineer I | 23andMe | Jul 2019 - May 2020"},{"location":"resume/#software-engineer-cisco-jul-2018-jul-2019","text":"Brought onto Cisco's Engineering Licensing team as the first hire on a new project intended to serve Cisco's licensing needs for its present and future cloud products. Delivered to 3 product teams including Cisco's new DNA Center . Re-engineered Cisco's Smart Licensing for Python and the cloud. Designed goals and deadlines for long term projects. Screened, interviewed, recommended, and trained new hires.","title":"Software Engineer | Cisco | Jul 2018 - Jul 2019"},{"location":"resume/#platforms-engineer-primer-ai-nov-2017-apr-2018","text":"Part of a growing team of engineers tasked with supporting data scientists developing machine learning solutions to text based problems. Added backend REST API features and expanded test coverage. Built and deployed simple micro service using Python and Flask. Learned React on the job to aide in developing frontend components. Introduced teams to Jupyter as a tool for reproducible and shareable science.","title":"Platforms Engineer | Primer AI | Nov 2017 - Apr 2018"},{"location":"resume/#engineer-in-test-apple-maps-jul-2017-nov-2017","text":"One of two engineers brought on to develop a UI test automation framework for a map editor used in the production pipeline for Apple Maps. Developed a framework around Selenium for easily testing UI applications. Expanded test coverage to relieve manual testers. Communicated with core devs to ensure products meet expectations.","title":"Engineer in Test | Apple Maps | Jul 2017 - Nov 2017"},{"location":"resume/#supplemental-work","text":"","title":"Supplemental Work"},{"location":"resume/#23andmentor-23andme-jul-2020-sep-2020","text":"Participated in 23andMe's mentoship pilot program. Taught a collegue with minimal coding experience to code in Python through 1-2 hour weekly sessions. The curiculum was relatively unstructured and primarilly guided by the mentee's curiosities and interests. By the end of the program the mentee was able to: Write Python scripts to solve basic algorithms questions Reach out to other colleagues to find ways to apply her newfound skills","title":"23andMentor | 23andMe | Jul 2020 - Sep 2020"},{"location":"resume/#gsoc-mentor-matplotlib-jun-2017-sep-2017","text":"Guided a student through Google's Summer of Code as their sole mentor in order to continue the work of integrating Traitlets into Matplotlib. Reviewed the student's code Introduced them to Git and GitHub as tools for collaboration Organized and enforced regular meetings to display daily progress.","title":"GSOC Mentor | Matplotlib | Jun 2017 - Sep 2017"},{"location":"resume/#owned-projects","text":"","title":"Owned Projects"},{"location":"resume/#idom-react-but-in-python","text":"Gives Python developers the power to create interactive web applications without writing a single line of Javascript. IDOM takes large inspiration from React Hooks and effectively replicates their behavior enabling users to define declarative and composable UI components.","title":" IDOM - React, but in Python"},{"location":"resume/#spectate-mvc-for-python","text":"A library for Python 2 and 3 that can track changes to mutable data types. With spectate complicated protocols for managing updates don't need to be the outward responsibility of a user and can instead be done \"automagically\" in the background. For instance, syncing the state between a server and client can controlled by spectate so user's don't have to.","title":" Spectate - MVC for Python"},{"location":"resume/#maintained-projects","text":"","title":"Maintained Projects"},{"location":"resume/#traitlets-ipython-and-jupyter","text":"Traitlets is a pure Python library for enforcing strong typing, observing changes to tracked data, and reading configuring values from files or from command line arguments. Traitlets powers the configuration system of IPython and Jupyter and the declarative API of IPython's interactive widgets .","title":" Traitlets - IPython and Jupyter"},{"location":"resume/#recommendations","text":"His knowledge of the inner workings of Python are easily some of the best I\u2019ve seen... he is also one of the most genuine and cooperative people I have had the pleasure of working with. Alvin Yates - Former Manager","title":"Recommendations"},{"location":"resume/#education","text":"B.A. Physics","title":"Education"},{"location":"articles/2021/idom-react-but-its-python/article/","text":"IDOM - It's React, but in Python IDOM is a new declarative Python package for building highly interactive and composable user interfaces. IDOM takes inspiration from React , and wherever possible, attempts to achieve parity with the features it copies more directly. Nowhere is this more evident than the version of React's often lauded \"Hooks\" that IDOM implements in Python. At a glance, the similarities between IDOM and React are rather striking. Below is a React component which defines a simple Slideshow displaying an image that updates when a user clicks on it: import React , { useState } from react ; function Slideshow () { const [ index , setIndex ] = useState ( 0 ); return ( < img src = { `https://picsum.photos/400?image= ${ index } ` } onClick = { () => setIndex ( index + 1 ) } style = { { cursor : \"pointer\" } } /> ) } And this is the same component implemented in Python using IDOM: import idom @idom . component def Slideshow (): index , set_index = idom . hooks . use_state ( 0 ) return idom . html . img ( { \"src\" : f \"https://picsum.photos/400?image= { index } \" , \"onClick\" : lambda event : set_index ( index + 1 ), \"style\" : { \"cursor\" : \"pointer\" }, } ) idom . run ( Slideshow ) Why Do We Need IDOM? Over the past 5 years front-end developers seem to have arrived at the conclusion that declarative programming is usually better than imperative. Put more simply, mutable state in programs can quickly lead to unsustainable complexity. This trend is largely evidenced by the rise of Javascript frameworks like Vue and React which describe the logic of computations without explicitly stating their control flow. So what does this have to do with Python and IDOM? Well, because browsers are the de facto \"operating system of the internet\", even back-end languages like Python have had to figure out clever ways to integrate with them. While standard REST APIs are well suited to applications built using HTML templates, modern browser users expect a higher degree of interactivity than this alone can achieve. A variety of Python packages have since been created to help solve this problem: IPyWidgets - Adds interactive widgets to Jupyter Notebooks Dash - Allows data scientists to produces enterprise-ready analytic apps Streamlit - Turns simple Python scripts into interactive dashboards Bokeh - An interactive visualization library for modern web browsers However they each have drawbacks that can make them difficult to use. Restrictive ecosystems - UI components developed for one framework cannot be easily ported to any of the others because their APIs are either too complex, undocumented, or are structurally inaccesible. Imperative paradigm - IPyWidgets and Bokeh have not embraced the same declarative design principles pioneered by front-end developers. Streamlit and Dash on the otherhand, are decarative, but fall short of the features provided by React or Vue. Limited layouts - At their initial inception, the developers of these libraries were driven by the visualization needs of data scientists so the ability to create complex UI layouts may not have been a primary engineering goal. A future article will address specific comparisons to each of the projects mentioned above, but for now, we'll just focus on IDOM and its solutions to the problems above. Ecosystem Independence IDOM has a flexible set of core abstractions that allow it to easily interface with its peers. At the time of writing both Jupyter and Dash are already supported (Streamlit and Bokeh are in the works): idom-jupyter (try it now with Binder ) idom-dash By providing well defined interfaces and straighforward protocols, IDOM makes it easy to swap out any part of the stack with an alternate implementation if you need to. For example, if you need to use a different web server for your application, IDOM already has 3 options to choose from or use as blueprints to create your own. Sanic Flask Tornado You can even target your usage of IDOM in your production-grade applications with IDOM's Javascript React client library . Just install it in your front-end app and connect a back-end websocket that's serving up IDOM models. IDOM's own documentation acts as a prime example for this targeted usage - most of the page is static HTML, but embedded in it are interactive examples that feature live views being served from a web socket: Declarative Components IDOM, by adopting the hook design pattern from React, inherits many of its aesthetic and functional characteristics. For those unfamiliar with hooks, user interfaces are composed of basic HTML elements that are constructed and returned by special functions called \"components\". Then, through the magic of hooks, those components can be made to have state. Consider the component below which returns two buttons that, when pressed, update and some text: import idom @idom . component def OnOff (): state , set_state = idom . hooks . use_state ( False ) return idom . html . div ( idom . html . button ({ \"onClick\" : lambda event : set_state ( True ), \"On\" ), idom . html . button ({ \"onClick\" : lambda event : set_state ( False ), \"Off\" ), idom . html . p ( \"The button is \" + ( \"on\" if state else \"off\" )), ) Here's a very high level summary of how it works... the first time a view of the component above is rendered, the OnOff function is called where the initial state is False . The function then returns a series of HTML elements with callbacks that respond to client-side events. Machinery behind the scenes then realizes that declaration and displays two buttons with the text \"The button is off\" . Then, when a user clicks the now visible \"On\" button, a client-side event is triggered, the associated callback responds to it by setting the state to True , and a re-render of the component is scheduled. The internal machinery again goes to work to update the display, this time though, the text will read \"The button is on\" because of the state change. Nowhere in the example above does the code describe how to evolve the frontend view when events occur. Instead, it declares that, given a particular state, this is how it should look. It's then IDOM's responsibility to figure out how to make that happen. This behavior of defining outcomes without stating the means by which to achieve them is what makes components in IDOM and React \"declarative\". For comparison, a hypothetical, and a more imperative approach to defining the same interface might look similar to the following: layout = Layout () def on_off (): on_off_text = html . p ( children = \"The button is off\" ) def set_on ( event ): on_off_text . update ( children = \"The button is on\" ) def set_off ( event ): on_off_text . update ( children = \"The button is off\" ) return html . div ( html . button ( on_click = set_on , children = \"On\" ), html . button ( on_click = set_off , children = \"Off\" ), on_off_text , ) layout . add_element ( on_off ()) In this imperative incarnation, we must explicitely state how the \"On\" and \"Off\" buttons update on_off_text via its on_click callback. We should also note that state is mutated by ammending the children of the on_off_text . It's important to note that neither declarative nor imperative design principle are inherently better in all circumstances. However, it is often the case that asserting the way a view should look is easier than describing how it should come to look that way. Flexible Layouts Constructing complex layouts is also made easier when done declaratively because the elements, state, and logic that comprise them are not entangled. As in the OnOff component shown above, code responsible for managing business logic and manipulating state can be clearly detached from the code responsible for structuring the elements of the layout. The great advantage of this approach is that these sections of code can be easily factored out into separate functions if either the logic or the structure becomes too complex: @idom . component def OnOff (): return on_off_buttons ( * use_on_off_state ()) def use_on_off_state (): \"\"\"manage logic and state\"\"\" state , set_state = idom . hooks . use_state ( False ) def set_on (): set_state ( True ) def set_off () set_state ( False ) return state , set_on , set_off def on_off_buttons ( state , set_on , set_off ): \"\"\"define element structure\"\"\" return idom . html . div ( idom . html . button ({ \"onClick\" : lambda event : set_on (), \"On\" ), idom . html . button ({ \"onClick\" : lambda event : set_off (), \"Off\" ), idom . html . p ( \"The button is \" + ( \"on\" if state else \"off\" )), ) While the refactoring above is overkill in such a simple case, attempting something similar with the ealier imperative example wouldn't be as straighforward because callbacks responsible for defining business logic must hold a reference to the elements they intend to update. The effect is that the description of the layout in code is often muddled by semantic limitations of the business logic that make it difficult to maintain as the code develops and grows old. Conclusion Building highly interactive web applications as a Python developer has historically been a great challenge. However IDOM changes that. Knowing just basic HTML, CSS, and Python, you can make everything from slideshows to dashboards and use it wherever you need it, whether that's in a Jupyter Notebook or an existing web application. To learn more check it out: installation instructions where to get started interactive examples and much more !","title":"IDOM - It's React, but in Python"},{"location":"articles/2021/idom-react-but-its-python/article/#idom-its-react-but-in-python","text":"IDOM is a new declarative Python package for building highly interactive and composable user interfaces. IDOM takes inspiration from React , and wherever possible, attempts to achieve parity with the features it copies more directly. Nowhere is this more evident than the version of React's often lauded \"Hooks\" that IDOM implements in Python. At a glance, the similarities between IDOM and React are rather striking. Below is a React component which defines a simple Slideshow displaying an image that updates when a user clicks on it: import React , { useState } from react ; function Slideshow () { const [ index , setIndex ] = useState ( 0 ); return ( < img src = { `https://picsum.photos/400?image= ${ index } ` } onClick = { () => setIndex ( index + 1 ) } style = { { cursor : \"pointer\" } } /> ) } And this is the same component implemented in Python using IDOM: import idom @idom . component def Slideshow (): index , set_index = idom . hooks . use_state ( 0 ) return idom . html . img ( { \"src\" : f \"https://picsum.photos/400?image= { index } \" , \"onClick\" : lambda event : set_index ( index + 1 ), \"style\" : { \"cursor\" : \"pointer\" }, } ) idom . run ( Slideshow )","title":"IDOM - It's React, but in Python"},{"location":"articles/2021/idom-react-but-its-python/article/#why-do-we-need-idom","text":"Over the past 5 years front-end developers seem to have arrived at the conclusion that declarative programming is usually better than imperative. Put more simply, mutable state in programs can quickly lead to unsustainable complexity. This trend is largely evidenced by the rise of Javascript frameworks like Vue and React which describe the logic of computations without explicitly stating their control flow. So what does this have to do with Python and IDOM? Well, because browsers are the de facto \"operating system of the internet\", even back-end languages like Python have had to figure out clever ways to integrate with them. While standard REST APIs are well suited to applications built using HTML templates, modern browser users expect a higher degree of interactivity than this alone can achieve. A variety of Python packages have since been created to help solve this problem: IPyWidgets - Adds interactive widgets to Jupyter Notebooks Dash - Allows data scientists to produces enterprise-ready analytic apps Streamlit - Turns simple Python scripts into interactive dashboards Bokeh - An interactive visualization library for modern web browsers However they each have drawbacks that can make them difficult to use. Restrictive ecosystems - UI components developed for one framework cannot be easily ported to any of the others because their APIs are either too complex, undocumented, or are structurally inaccesible. Imperative paradigm - IPyWidgets and Bokeh have not embraced the same declarative design principles pioneered by front-end developers. Streamlit and Dash on the otherhand, are decarative, but fall short of the features provided by React or Vue. Limited layouts - At their initial inception, the developers of these libraries were driven by the visualization needs of data scientists so the ability to create complex UI layouts may not have been a primary engineering goal. A future article will address specific comparisons to each of the projects mentioned above, but for now, we'll just focus on IDOM and its solutions to the problems above.","title":"Why Do We Need IDOM?"},{"location":"articles/2021/idom-react-but-its-python/article/#ecosystem-independence","text":"IDOM has a flexible set of core abstractions that allow it to easily interface with its peers. At the time of writing both Jupyter and Dash are already supported (Streamlit and Bokeh are in the works): idom-jupyter (try it now with Binder ) idom-dash By providing well defined interfaces and straighforward protocols, IDOM makes it easy to swap out any part of the stack with an alternate implementation if you need to. For example, if you need to use a different web server for your application, IDOM already has 3 options to choose from or use as blueprints to create your own. Sanic Flask Tornado You can even target your usage of IDOM in your production-grade applications with IDOM's Javascript React client library . Just install it in your front-end app and connect a back-end websocket that's serving up IDOM models. IDOM's own documentation acts as a prime example for this targeted usage - most of the page is static HTML, but embedded in it are interactive examples that feature live views being served from a web socket:","title":"Ecosystem Independence"},{"location":"articles/2021/idom-react-but-its-python/article/#declarative-components","text":"IDOM, by adopting the hook design pattern from React, inherits many of its aesthetic and functional characteristics. For those unfamiliar with hooks, user interfaces are composed of basic HTML elements that are constructed and returned by special functions called \"components\". Then, through the magic of hooks, those components can be made to have state. Consider the component below which returns two buttons that, when pressed, update and some text: import idom @idom . component def OnOff (): state , set_state = idom . hooks . use_state ( False ) return idom . html . div ( idom . html . button ({ \"onClick\" : lambda event : set_state ( True ), \"On\" ), idom . html . button ({ \"onClick\" : lambda event : set_state ( False ), \"Off\" ), idom . html . p ( \"The button is \" + ( \"on\" if state else \"off\" )), ) Here's a very high level summary of how it works... the first time a view of the component above is rendered, the OnOff function is called where the initial state is False . The function then returns a series of HTML elements with callbacks that respond to client-side events. Machinery behind the scenes then realizes that declaration and displays two buttons with the text \"The button is off\" . Then, when a user clicks the now visible \"On\" button, a client-side event is triggered, the associated callback responds to it by setting the state to True , and a re-render of the component is scheduled. The internal machinery again goes to work to update the display, this time though, the text will read \"The button is on\" because of the state change. Nowhere in the example above does the code describe how to evolve the frontend view when events occur. Instead, it declares that, given a particular state, this is how it should look. It's then IDOM's responsibility to figure out how to make that happen. This behavior of defining outcomes without stating the means by which to achieve them is what makes components in IDOM and React \"declarative\". For comparison, a hypothetical, and a more imperative approach to defining the same interface might look similar to the following: layout = Layout () def on_off (): on_off_text = html . p ( children = \"The button is off\" ) def set_on ( event ): on_off_text . update ( children = \"The button is on\" ) def set_off ( event ): on_off_text . update ( children = \"The button is off\" ) return html . div ( html . button ( on_click = set_on , children = \"On\" ), html . button ( on_click = set_off , children = \"Off\" ), on_off_text , ) layout . add_element ( on_off ()) In this imperative incarnation, we must explicitely state how the \"On\" and \"Off\" buttons update on_off_text via its on_click callback. We should also note that state is mutated by ammending the children of the on_off_text . It's important to note that neither declarative nor imperative design principle are inherently better in all circumstances. However, it is often the case that asserting the way a view should look is easier than describing how it should come to look that way.","title":"Declarative Components"},{"location":"articles/2021/idom-react-but-its-python/article/#flexible-layouts","text":"Constructing complex layouts is also made easier when done declaratively because the elements, state, and logic that comprise them are not entangled. As in the OnOff component shown above, code responsible for managing business logic and manipulating state can be clearly detached from the code responsible for structuring the elements of the layout. The great advantage of this approach is that these sections of code can be easily factored out into separate functions if either the logic or the structure becomes too complex: @idom . component def OnOff (): return on_off_buttons ( * use_on_off_state ()) def use_on_off_state (): \"\"\"manage logic and state\"\"\" state , set_state = idom . hooks . use_state ( False ) def set_on (): set_state ( True ) def set_off () set_state ( False ) return state , set_on , set_off def on_off_buttons ( state , set_on , set_off ): \"\"\"define element structure\"\"\" return idom . html . div ( idom . html . button ({ \"onClick\" : lambda event : set_on (), \"On\" ), idom . html . button ({ \"onClick\" : lambda event : set_off (), \"Off\" ), idom . html . p ( \"The button is \" + ( \"on\" if state else \"off\" )), ) While the refactoring above is overkill in such a simple case, attempting something similar with the ealier imperative example wouldn't be as straighforward because callbacks responsible for defining business logic must hold a reference to the elements they intend to update. The effect is that the description of the layout in code is often muddled by semantic limitations of the business logic that make it difficult to maintain as the code develops and grows old.","title":"Flexible Layouts"},{"location":"articles/2021/idom-react-but-its-python/article/#conclusion","text":"Building highly interactive web applications as a Python developer has historically been a great challenge. However IDOM changes that. Knowing just basic HTML, CSS, and Python, you can make everything from slideshows to dashboards and use it wherever you need it, whether that's in a Jupyter Notebook or an existing web application. To learn more check it out: installation instructions where to get started interactive examples and much more !","title":"Conclusion"}]}